// scripts/generate-routes.mjs
import fs from 'node:fs';
import path from 'node:path';
import url from 'node:url';

const projectRoot = process.cwd();
const pagesDir = path.join(projectRoot, 'src', 'pages');
const outFile = path.join(projectRoot, 'src', 'router', 'AppRoutes.tsx');
const overridesFile = path.join(projectRoot, 'routes.overrides.mjs');

const kebab = (s) =>
  s
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();

const relUnix = (p) => p.split(path.sep).join('/');

function walk(dir) {
  /** @type {string[]} */
  const files = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) files.push(...walk(full));
    else if (/\.(tsx|jsx)$/.test(entry.name)) files.push(full);
  }
  return files;
}

function defaultPathFor(fileRel) {
  // derive route from file path
  // examples:
  // 'About.tsx' -> '/about'
  // 'lms/Home.tsx' -> '/lms/home'
  // 'NotFound.tsx' -> '*' (handled by overrides or below)
  const base = fileRel.replace(/\.(tsx|jsx)$/, '');
  const parts = base.split('/');
  const mapped = parts.map(kebab);
  const route = '/' + mapped.join('/');
  return route;
}

async function main() {
  // ensure output dir
  fs.mkdirSync(path.dirname(outFile), { recursive: true });

  // load overrides (optional)
  let overrides = [];
  if (fs.existsSync(overridesFile)) {
    // dynamic import ESM
    const overridesUrl = url.pathToFileURL(overridesFile).href;
    overrides = (await import(overridesUrl)).default || [];
  }

  // resolve page files
  const filesAbs = walk(pagesDir);
  const filesRel = filesAbs.map((f) => relUnix(path.relative(pagesDir, f)));

  // Validate override file existence
  for (const o of overrides) {
    const exists = filesRel.includes(relUnix(o.file));
    if (!exists) {
      console.error(`[routes] Override references missing file: ${o.file}`);
      process.exit(1);
    }
  }

  // Build route table
  /** @type {Array<{ fileRel: string; importPath: string; path: string }>} */
  const table = [];

  // 1) all files get default routes
  for (const fr of filesRel) {
    // Skip obvious non-routes if you have any (e.g. components under pages/_shared)
    if (fr.startsWith('_') || fr.includes('/_')) continue;

    let pth = defaultPathFor(fr);

    // NotFound special-case if file name equals NotFound.tsx
    if (/\/?NotFound\.(tsx|jsx)$/.test(fr)) pth = '*';

    table.push({
      fileRel: fr,
      importPath: `../pages/${fr}`,
      path: pth,
    });
  }

  // 2) apply overrides (replace default for same file)
  for (const o of overrides) {
    const idx = table.findIndex((r) => r.fileRel === relUnix(o.file));
    if (idx >= 0) table[idx].path = o.path;
    else {
      // if override is for a file that was filtered earlier, add it
      table.push({
        fileRel: relUnix(o.file),
        importPath: `../pages/${relUnix(o.file)}`,
        path: o.path,
      });
    }
  }

  // Deduplicate by (path) preferring overrides (last write wins)
  const byPath = new Map();
  for (const r of table) byPath.set(r.path, r);
  const finalRoutes = Array.from(byPath.values());

  // Generate static lazy imports and <Route> elements
  const lines = [];
  lines.push(
    `/* AUTO-GENERATED by scripts/generate-routes.mjs – DO NOT EDIT */`
  );
  lines.push(`import React, { lazy, Suspense } from 'react';`);
  lines.push(`import { Routes, Route } from 'react-router-dom';`);
  lines.push(`import SiteLayout from '../layouts/SiteLayout';`);
  lines.push(``);
  // Error boundary
  lines.push(
    `class RouteErrorBoundary extends React.Component{constructor(p){super(p);this.state={e:null}}static getDerivedStateFromError(e){return{e}}componentDidCatch(e,i){console.error('Route error:',e,i)}render(){return this.state.e?React.createElement('pre',null,String(this.state.e?.message||this.state.e)):this.props.children}}`
  );
  lines.push(
    `const Fallback = () => <div className="min-h-screen grid place-items-center">Loading…</div>;`
  );
  lines.push(``);

  // imports
  const importIds = [];
  finalRoutes.forEach((r, i) => {
    const id = `Page_${i}`;
    importIds.push({ id, ...r });
    // static string – good for Vite chunking
    lines.push(`const ${id} = lazy(() => import('${r.importPath}'));`);
  });

  lines.push(``);
  lines.push(`export default function AppRoutes(){`);
  lines.push(`  return (`);
  lines.push(`    <RouteErrorBoundary>`);
  lines.push(`      <Suspense fallback={<Fallback />}>`);
  lines.push(`        <SiteLayout>`);
  lines.push(`          <Routes>`);

  // ensure * is last
  importIds.sort((a, b) => (a.path === '*' ? 1 : b.path === '*' ? -1 : 0));

  for (const { id, path: routePath } of importIds) {
    lines.push(`            <Route path="${routePath}" element={<${id} />} />`);
  }

  lines.push(`          </Routes>`);
  lines.push(`        </SiteLayout>`);
  lines.push(`      </Suspense>`);
  lines.push(`    </RouteErrorBoundary>`);
  lines.push(`  );`);
  lines.push(`}`);
  lines.push(``);

  fs.writeFileSync(outFile, lines.join('\n'), 'utf8');

  console.log(
    `[routes] Generated ${finalRoutes.length} routes -> ${relUnix(path.relative(projectRoot, outFile))}`
  );
}

main().catch((err) => {
  console.error('[routes] Failed:', err);
  process.exit(1);
});
