name: Autopilot Health Check

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:

jobs:
  health-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check required secrets
        id: check-secrets
        run: |
          MISSING=()
          if [ -z "${{ secrets.NETLIFY_AUTH_TOKEN }}" ]; then
            MISSING+=("NETLIFY_AUTH_TOKEN")
          fi
          if [ -z "${{ secrets.NETLIFY_SITE_ID }}" ]; then
            MISSING+=("NETLIFY_SITE_ID")
          fi
          
          if [ ${#MISSING[@]} -gt 0 ]; then
            echo "::error::Missing required secrets: ${MISSING[*]}"
            echo "has_secrets=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "has_secrets=true" >> $GITHUB_OUTPUT
          fi

      - name: Run health check script
        if: steps.check-secrets.outputs.has_secrets == 'true'
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          node - <<'EOF'
          const fs = require('fs');
          const path = require('path');
          
          const STATUS_FILE = 'AUTOPILOT_SYSTEM/status.json';
          
          async function checkHealth() {
            console.log('üè• Running Autopilot Health Check...\n');
            
            // Ensure directory exists
            const dir = path.dirname(STATUS_FILE);
            if (!fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
            
            // Read existing status or create default
            let status = {
              timestamp: new Date().toISOString(),
              deployId: 'unknown',
              hasWorkerScript: false,
              hasDurableScript: false,
              status: 'unknown'
            };
            
            if (fs.existsSync(STATUS_FILE)) {
              try {
                status = JSON.parse(fs.readFileSync(STATUS_FILE, 'utf8'));
                console.log('‚úÖ Existing status file found');
              } catch (error) {
                console.log('‚ö†Ô∏è  Could not parse status file, creating new one');
              }
            } else {
              console.log('‚ÑπÔ∏è  No status file found, creating new one');
            }
            
            // Query Netlify for latest deploy if we have credentials
            if (process.env.NETLIFY_AUTH_TOKEN && process.env.NETLIFY_SITE_ID) {
              try {
                console.log('üîç Checking Netlify deploy status...');
                
                const response = await fetch(
                  `https://api.netlify.com/api/v1/sites/${process.env.NETLIFY_SITE_ID}/deploys?per_page=1`,
                  {
                    headers: {
                      'Authorization': `Bearer ${process.env.NETLIFY_AUTH_TOKEN}`
                    }
                  }
                );
                
                if (response.ok) {
                  const deploys = await response.json();
                  if (deploys && deploys.length > 0) {
                    const latestDeploy = deploys[0];
                    status.lastDeployId = latestDeploy.id;
                    status.lastDeployState = latestDeploy.state;
                    status.lastDeployCreated = latestDeploy.created_at;
                    console.log(`‚úÖ Latest deploy: ${latestDeploy.id} (${latestDeploy.state})`);
                  }
                } else {
                  console.log(`‚ö†Ô∏è  Netlify API returned status ${response.status}`);
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è  Could not query Netlify: ${error.message}`);
              }
            }
            
            // Update status with current timestamp
            status.lastHealthCheck = new Date().toISOString();
            status.healthCheckPassed = true;
            
            // Write updated status
            fs.writeFileSync(STATUS_FILE, JSON.stringify(status, null, 2));
            console.log(`\n‚úÖ Health check complete. Status updated: ${STATUS_FILE}`);
            
            return status;
          }
          
          checkHealth().catch(error => {
            console.error('‚ùå Health check failed:', error);
            process.exit(1);
          });
          EOF

      - name: Commit status updates
        if: steps.check-secrets.outputs.has_secrets == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add AUTOPILOT_SYSTEM/status.json || true
          git diff --cached --quiet || git commit -m "chore: update autopilot health status [skip ci]"
          git push || echo "Nothing to push"
